---
sidebar_position: 1
---

# 8.1、使用打洞和中继
:::tip[说明]
1. 在你的.NET8.0+项目中，集成linker的打洞和中继
2. 分别在服务端和客户端使用nuget安装`linker.messenger`,`linker.messenger.signin`,`linker.messenger.tunnel`,`linker.messenger.relay`
3. 然后参照样例[https://github.com/snltty/linker/tree/master/linker.messenger.example](https://github.com/snltty/linker/tree/master/linker.messenger.example)

:::

## 1、自定义登录参数和验证

:::tip[说明]
实现自定义的登录参数验证，
```
//在客户端和服务端操作
SignInArgsTransfer signInArgsTransfer = new SignInArgsTransfer();
//加载你写的类
signInArgsTransfer.LoadArgs(new List<ISignInArgs> {
    new MySignInArgs()
});


//在客户端，登录操作事情执行一下，然后把 argsDic 传过去就行
Dictionary<string, string> argsDic = new Dictionary<string, string>();
await signInArgsTransfer.Invoke(string.Empty, argsDic);
//像这样传过去
MessageResponeInfo resp = await messengerSender.SendReply(new MessageRequestWrap
{
    Connection = 与服务器的连接对象,
    MessengerId = (ushort)SignInMessengerIds.SignIn_V_1_3_1,
    Timeout = 2000,
    Payload = serializer.Serialize(new SignInfo
    {
        MachineName = Dns.GetHostName(),
        MachineId = string.Empty,
        Version = VersionHelper.version,
        Args = argsDic,
        GroupId = "default"
    })
}).ConfigureAwait(false);


public sealed class MySignInArgs : ISignInArgs
{
    /// <summary>
    /// 客户端调用
    /// </summary>
    /// <param name="host"></param>
    /// <param name="args"></param>
    /// <returns></returns>
    public async Task<string> Invoke(string host, Dictionary<string, string> args)
    {
        //在这里加入你喜欢的数据

        //返回空字符串，表示成功，不空为错误信息
        return await Task.FromResult(string.Empty);
    }

    /// <summary>
    /// 服务端调用
    /// </summary>
    /// <param name="signInfo">本次登录的信息</param>
    /// <param name="cache">如果以前登录过就有信息，否则MachineId为空</param>
    /// <returns></returns>
    /// <exception cref="NotImplementedException"></exception>
    public async Task<string> Validate(SignInfo signInfo, SignCacheInfo cache)
    {
        //在这里进行你的验证

        //返回空字符串，表示成功，不空为错误信息则登录失败
        return await Task.FromResult(string.Empty);
    }
}
```
:::

## 1、自定义中继认证

:::tip[说明]
实现自定义的中继验证，
```
//在服务端操作
RelayServerValidatorTransfer relayServerValidatorTransfer = new RelayServerValidatorTransfer();
//加载你写的类
relayServerValidatorTransfer.LoadValidators(new List<IRelayServerValidator> {
    new MyRelayServerValidator()
});

public sealed class MyRelayServerValidator : IRelayServerValidator
{
    /// <summary>
    /// 验证，服务端会调用
    /// </summary>
    /// <param name="relayInfo">中继参数</param>
    /// <param name="fromMachine">来源客户端</param>
    /// <param name="toMachine">目标客户端</param>
    /// <returns></returns>
    public async Task<string> Validate(RelayInfo relayInfo, SignCacheInfo fromMachine, SignCacheInfo toMachine)
    {
        //返回空字符串，表示成功，不空为错误信息则登录失败
        return await Task.FromResult(string.Empty);
    }
}
```
:::